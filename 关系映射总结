cascade没有写，即是默认值，就是不级联的意思。
这个和user_role关系表没关系！user_role表的映射关系的维护，和cascade写不写，写什么值一点关系都没有
	中间表
如果，你发现User针对Role属性的cascade没有写，但是修改了role的值，确发生变更了，打印出sql语句，也发现还是级联更新了，咋回事？
这个我也郁闷了好久，hibernate真心不好用，太复杂了。经过苦心调试终于明白了。不是cascade不写没有用，而是你对role的变更是不是先查询出来的持久对象的操作。这样的操作是针对Role持久化对象的修改，和级联没关系，就是说你直接修改了role对象，当然更新了值！

  /** Cascade all operations 级联所有操作 */
    ALL,

    /** Cascade persist operation 级联新增 */
    PERSIST,

    /** Cascade merge operation 级联更新或者新增 */
    MERGE,

    /** Cascade remove operation 级联删除 */
    REMOVE,

    /** Cascade refresh operation 级联刷新 */
    REFRESH,
	假设场景 有一个订单,订单里面关联了许多商品,这个订单可以被很多人操作,
	那么这个时候A对此订单和关联的商品进行了修改,与此同时,B也进行了相同的操作,
	但是B先一步比A保存了数据,那么当A保存数据的时候,就需要先刷新订单信息及关联的商品信息后,
	再将订单及商品保存

    /**
     * Cascade detach operation
     * 级联分离
     * @since Java Persistence 2.0
     *
     */
    DETACH
	如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联。
		
fetch默认值 EAGER 急加载
默认情况下，jpa持续性提供程序使用获取类型EAGER：这将要求持续性提供程序运行时必须迫切获取数据
    Lazy: 只有需要的时候才将相关联的实体取出
    EAGER: 一次将所有相关联的实体取出
懒加载是在属性被引用时，才生成查询语句，抽取相关联数据。
而实时加载则是执行完主查询后,不管是否被引用,立马执行后续的关联数据查询

lazy 查询了两次 性能好
select teacher0_.id as id1_4_0_, teacher0_.name as name2_4_0_ from teacher teacher0_ where teacher0_.id=5

select stus0_.teacher_id as teacher_1_5_0_, stus0_.stus_id as stus_id2_5_0_, student1_.id as id1_1_1_, student1_.name as name2_1_1_ from teacher_stus stus0_ inner join student student1_ on stus0_.stus_id=student1_.id where stus0_.teacher_id=5

EAGER一次查询出全部
select teacher0_.id as id1_4_0_, teacher0_.name as name2_4_0_, stus1_.teacher_id as teacher_1_5_1_, student2_.id as stus_id2_5_1_, student2_.id as id1_1_2_, student2_.name as name2_1_2_ from teacher teacher0_ left outer join teacher_stus stus1_ on teacher0_.id=stus1_.teacher_id left outer join student student2_ on stus1_.stus_id=student2_.id where teacher0_.id=5


lazy有 no session问题
解决LazyInitializationException异常大概有这么几种方式
1.关闭LazyInitialization, 将fetch设成eager
2.在spring boot的配置文件application.properties添加spring.jpa.open-in-view=true
3.用spring 的OpenSessionInViewFilter
4. @Test 测试时使用@Transactional
原文：https://blog.csdn.net/chrislyl/article/details/54630413 

mappedBy指定many为多方关系的被维护端